name: Build release bundle

on:
  workflow_dispatch:
    inputs:
        previous_version:
          description: 'Previous Version'
          required: true
        version:
          description: 'New Version'
          required: true
        is_major:
          description: 'Major update'
          required: false
          type: boolean
          default: false
        force_pnpm_install:
          description: 'Force fresh pnpm install'
          required: false
          type: boolean
          default: false

permissions:
  contents: write
  
jobs:        
  build_release_bundle:
    runs-on: windows-latest
    steps:
        - name: Set up Node.js
          uses: actions/setup-node@v4
          with:
            node-version: '20'

        - name: Install pnpm
          uses: pnpm/action-setup@v3
          with:
            version: latest

        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: '3.x'
  
        - name: Set up Rust
          uses: dtolnay/rust-toolchain@stable

        - name: Set up MSBuild
          uses: microsoft/setup-msbuild@v2

        - name: Checkout repository
          uses: actions/checkout@v4
          with:
            submodules: recursive

        - name: Cache pnpm dependencies
          id: cache-pnpm
          uses: actions/cache@v4
          with:
            path: |
              ~/.pnpm-store
              node_modules
            key: ${{ runner.OS }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
            restore-keys: |
              ${{ runner.OS }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}-

        - name: Install dependencies (pnpm)
          if: steps.cache-pnpm.outputs.cache-hit != 'true' || inputs.force_pnpm_install == 'true'
          run: pnpm install --frozen-lockfile

        - name: Cache nextjs build
          uses: actions/cache@v4
          with:
            path: |
              .next/cache
            key: ${{ runner.OS }}-nextjs-${{ hashFiles('**.[jt]s', '**.[jt]s') }}
            restore-keys: |
              ${{ runner.OS }}-nextjs-${{ hashFiles('**.[jt]s', '**.[jt]s') }}

        - name: Cache Cargo dependencies
          uses: actions/cache@v4
          with:
            path: |
              ~\.cargo\registry
              ~\.cargo\git
            key: ${{ runner.OS }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}
        
        - name: Cache Cargo target directory
          uses: actions/cache@v4
          with:
            path: |
              src-tauri\target
            key: ${{ runner.OS }}-cargo-build-tauri-target-${{ hashFiles('**/Cargo.lock') }}

        - name: Update versions
          id: update-versions
          run: |
            $tauriConf = Get-Content src-tauri/tauri.conf.json
            $updatedTauriConf = $tauriConf -replace "${{ github.event.inputs.previous_version }}", "${{ github.event.inputs.version }}"
            $updatedTauriConf | Set-Content src-tauri/tauri.conf.json
            $latest = Get-Content latest.json
            $updatedLatest = $latest -replace "${{ github.event.inputs.previous_version }}", "${{ github.event.inputs.version }}"
            $updatedLatest | Set-Content latest.json
            $changelog = Get-Content CHANGELOG.md
            $updatedChangelog = $changelog -replace "${{ github.event.inputs.previous_version }}", "${{ github.event.inputs.version }}"
            $updatedChangelog | Set-Content CHANGELOG.md

        - name: Create environment file
          run: |
            echo "KEY=${{ secrets.KEY }}" > .env.prod
          shell: pwsh
          working-directory: ${{ github.workspace }}

        - name: Build library files
          run: MSBuild.exe .\libs\SteamUtility.csproj
          shell: pwsh

        - name: Build Tauri release bundle
          if: steps.update-versions.outcome == 'success'
          run: |
            pnpm run tauri build
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
            TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          shell: pwsh

        - name: Update latest.json
          run: |
            python -c "
            import base64
            import json
            
            msi_signature_path = './src-tauri/target/release/bundle/msi/Steam Game Idler_${{ github.event.inputs.version }}_x64_en-US.msi.zip.sig'
            latest_json_path = './latest.json'
            
            with open(msi_signature_path, 'r') as sig_file:
                new_signature = sig_file.read().strip()
            
            with open(latest_json_path, 'r') as json_file:
                latest_json = json.load(json_file)
            
            latest_json['platforms']['windows-x86_64']['signature'] = new_signature
            
            is_major = True if '${{ github.event.inputs.is_major }}' == 'true' else False
            latest_json['major'] = is_major
            
            with open(latest_json_path, 'w') as json_file:
                json.dump(latest_json, json_file, indent=2)
            
            print('Updated latest.json with new signature')
            "

        - name: Commit changes
          run: |
            git config --local user.name "github-actions[bot]"
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git add src-tauri/tauri.conf.json latest.json CHANGELOG.md
            git commit -m "Bump version to ${{ github.event.inputs.version }}"
            git push

        - name: Create release
          uses: softprops/action-gh-release@v1
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          with:
            tag_name: ${{ github.event.inputs.version }}
            name: Steam Game Idler v${{ github.event.inputs.version }}
            body_path: ./changelog.md
            files: |
              ./src-tauri/target/release/bundle/msi/Steam Game Idler_${{ github.event.inputs.version }}_x64_en-US.msi
              ./src-tauri/target/release/bundle/msi/Steam Game Idler_${{ github.event.inputs.version }}_x64_en-US.msi.zip
              ./src-tauri/target/release/bundle/msi/Steam Game Idler_${{ github.event.inputs.version }}_x64_en-US.msi.zip.sig

        - name: Set version environment variable
          run: echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_ENV

  process-issues:
    runs-on: ubuntu-latest
    needs: build_release_bundle
    permissions:
      issues: write
      contents: read

    steps:
      - name: Process release body
        uses: actions/github-script@v7
        with:
          script: |
            let releaseInfo;
            
            const tag = process.env.VERSION;
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag
              });
              releaseInfo = release.data;
            } catch (error) {
              console.error(`Failed to fetch release info for tag ${tag}: ${error}`);
              return;
            }

            const releaseBody = releaseInfo.body || '';
            const issueRegex = /#(\d+)/g;
            const matches = [...releaseBody.matchAll(issueRegex)];

            if (matches.length === 0) {
              console.log('No issues referenced in release body');
              return;
            }

            const releaseTag = releaseInfo.tag_name;
            const releaseUrl = releaseInfo.html_url;
            const isPrerelease = releaseInfo.prerelease;

            // Rest of your existing code remains the same
            for (const match of matches) {
              const issueNumber = parseInt(match[1]);
              
              try {
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });

                if (issue.data.state === 'closed') {
                  console.log(`Issue #${issueNumber} is already closed. Skipping.`);
                  continue;
                }
                
                const labels = issue.data.labels.map(label => label.name);
                let newLabel = null;
                let commentBody = '';
                const releaseType = isPrerelease ? "pre-release" : "release";
                
                if (labels.includes('feature request')) {
                  newLabel = 'added';
                  commentBody = `This has been added in [${releaseTag}](${releaseUrl})`;
                  if (isPrerelease) {
                    commentBody += ". This is a pre-release version and is subject to changes";
                  }
                  commentBody += ". Thank you for your suggestion!";
                } else if (labels.includes('bug')) {
                  newLabel = 'fixed';
                  commentBody = `This has been fixed in [${releaseTag}](${releaseUrl})`;
                  if (isPrerelease) {
                    commentBody += ". This is a pre-release version and is subject to changes";
                  }
                  commentBody += ". Thank you for reporting!";
                } else {
                  commentBody = `This issue was referenced in [${releaseTag}](${releaseUrl}) so it has been closed`;
                  if (isPrerelease) {
                    commentBody += ". This is a pre-release version and is subject to changes.";
                  }
                }

                for (const label of labels) {
                  if (label !== 'bug' && label !== 'feature request') {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name: label
                    });
                  }
                }
                
                if (newLabel) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: [newLabel]
                  });
                }
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: commentBody
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed'
                });
                
                console.log(`Processed issue #${issueNumber} - Added label: ${newLabel || 'none'} - Release type: ${releaseType}`);
              } catch (error) {
                console.error(`Error processing issue #${issueNumber}: ${error}`);
              }
            }
